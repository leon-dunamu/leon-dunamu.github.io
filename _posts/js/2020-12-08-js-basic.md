---
layout: post
subtitle: "javascript 기본 지식"
title: "frontend 면접 대비 javascript 학습"
author: "Seog"
header-style: text
tags: 
  - Frontend
  - Javascript
---

frontend 면접 대비위한 js 핵심 모음 !

## 목차

| 목                                              | 차                                    | ⭐️                                          |
| ----------------------------------------------- | ------------------------------------- | -------------------------------------------- |
| <a href="#NumberType">Number Type</a>           | <a href="#context">실행 컨텍스트</a>  | <a href="#hoisting">호이스팅</a>             |
| <a href="#closure">클로저</a>                   | <a href="#garbage">가비지 컬렉터</a>  | <a href="#loop">이벤트 루프, 동시성 모델</a> |
| <a href="#proto">프로토타입</a>                 | <a href="#this">THIS</a>              | <a href="#es6">ES6</a>                       |
| <a href="#call">Call by value & call by ref</a> | <a href="#null">NULL vs undefined</a> | -                                            |

<br/>

## <span id="NumberType">Number Type</span>

다른언어에는 int double 등 숫자타입의 다양함이 있지만, `number는 하나만` 있다.<br/>
정수만을 위한 타입이 없고, **모든 수를 실수**로 처리한다.

```javascript
MAX_SAFE_INTEGER; // 약 9 천조, 수학적으로 안전한 수.

var a = MAX_SAFE_INTEGER + 1;
var b = MAX_SAFE_INTEGER + 2;

console.log(a === b); // true,,, 더 이상 안전한 수가 아니다
```

<br/>

## <span id="context">실행 컨택스트</span>

> 자바스크립트의 코드들이 <span style="font-weight:bold;color:purple;">실행되기 위한 환경</span>

전역 컨텍스트 ,함수 컨텍스트 2가지 존재

전역 컨텍스트 하나 생성 후에 `함수 호출할 때마다 함수 컨텍스트가 생성`

컨텍스트를 생성시에 **변수객체**, **스코프체인**, **this**가 생성된다.

컨텍스트 생성 후 함수가 실행되는데 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 `스코프체인`을 따라 올라가며 찾음.

함수 실행이 마무리되면 해당 컨텍스트는 사라짐. 페이지가 종료되면 전역 컨텍스트가 사라짐

즉, 자바스크립트의 코드가 실행되기 위해서는 **변수객체**, **스코프체인**, **this** 정보들을 담고 있는 곳을 실행컨텍스트라고 부른다.

<br/>

## <span id="hoisting">호이스팅</span>

> 변수를 선언하고 초기화 했을때 선언부분이 `최상단`으로 끌어올려지는 현상

예를들어, 코드 상단에서 console.log(a)를 찍고 하단에서 var a=1; 이라고 하였을때 a는 undefined라고 나온다. 이런 현상을 호이스팅이라고한다. 함수의 경우 함수표현식은 호이스팅이 적용되지 않으나 일반 함수선언문은 함수 호이스팅이 적용된다.

<br/>

## <span id="closure">클로저</span>

> 반환된 내부함수가 자신이 선언됬을때의 환경인 스코프를 기억하여 자신이 선언되었을때의 환경 밖에서 호출되어도 그 `환경에 접근`할 수 있는 함수.

**자신이 생성될때의 환경을 기억하는 함수**

사용 하는 이유 :

1. 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해
2. 전역 변수의 사용을 억제 하기위해
3. 정보를 은닉하기 위해

- 참고 : [클로저와 호이스팅](https://www.zerocho.com/category/JavaScript/post/5741d96d094da4986bc950a0)

<br/>

## <span id="garbage">가비지 컬렉터</span>

> 메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수하는 것.

자바스크립트에서 변수는 직접적으로 참조 값(문자열, 객체, 배열 등)을 담고 있지 않고, 해당 값을 메모리 상에 저장 된다. 그래서 참조 값을 생성하고나서 더이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서 메모리가 반환됨.(메모리를 다시 재사용할 수 있는 상태가 된다)

- 대표적인 방법 두 가지

  mark & sweep, reference-counting

다음은 순환참조로 인해 가비지 컬렉터가 작동하지 않는 경우이다

```javascript
function f() {
  var o = {};
  var o2 = {};
  o.a = o2; // o는 o2를 참조한다.
  o2.a = o; // o2는 o를 참조한다.

  return "azerty";
}

f();
```

위와 같이 서로 순환되어서 참조되어져서 가비지컬렉터가 작동하지 않고 메모리 누수가 발생된다.

null을 할당해서 연결을 끊는 방법을 사용한다.

대부분의 브라우저에서는 `Mark and sweep알고리즘`을 사용. 그래서 가비지컬렉터가 참조되지 않는 객체가 있을 때 동작하는 것이 아니라 접근 할 수 없는(닿을 수 없는) 객체 일 때 동작한다.

<br/>

## <span id="loop">이벤트 루프, 동시성 모델</span>

자바스크립트는 싱글 스레드 기반 언어이다. 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리 할 수 있다.

하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원한다. (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것이다)

이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행된다.

- [ECMAScript에는 이벤트 루프가 없다 [이벤트루프 추가설명]](https://meetup.toast.com/posts/89) 👍

  > 자바스크립트가 '단일 스레드' 기반의 언어라는 말은 '자바스크립트 엔진이 단일 호출 스택을 사용한다'는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(브라우저, Node.js등)에서는 주로 여러 개의 스레드가 사용되며, 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 '이벤트 루프'인 것이다.

- [추가 이벤트 루프 블로그](https://im-developer.tistory.com/113)

<br/>

## <span id="proto">프로토타입 </span>

자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거(중복 제거 방법은 기존의 코드를 재사용하는것!!)

즉, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해 놓음으로써 또 구현하는것이 아니라 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.

- \***\*proto** 접근자 프로퍼티\*\*

  자신의 프로토타입, 즉 Prototype 내부슬롯에 접근 할 수 있음.

- **프로토타입체인이란?**

  객체의 프로퍼티에 접근하려고 할때 객체에 접근하려는 프로퍼티가 없으면, **proto**접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로로타입체인의 최상위 객체는 Object.prototype이다. 이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다.

- **prototype 프로퍼티**

  생성자함수가 생성할 인스턴스의 프로토타입을 가르킨다.

- [참고](https://medium.com/@bluesh55/javascript-prototype-이해하기-f8e67c286b67)

<br/>

## <span id="this">THIS </span>

- **자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라**
- **일반함수의 this와 화살표 함수의 this는 어떻게 다른가?**

  > 자바스크립트의 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든지 this는 전역객체를 가르킴 <br/>
  > 일반함수의 this는 window(전역)을 가르키며, 화살표 함수의 this는 언제나 상위스코프의 this를 가르킴

- Call, Apply, Bind 함수에 대해 설명해달라

  > 3가지 방법은 this를 바인딩하기 위한 방법이다.
  > <br/>Call은 this를 바인딩하면서 함수를 호출하는 것, 두번째 인자를 apply와 다르게 하나씩 넘기는 것
  > <br/>Apply는 this를 바인딩하면서 함수를 호출하는 것, 두번째인자가 배열
  > <br/>Bind는 함수를 호출하는 것이 아닌 this가 바인딩 된 새로운 함수를 리턴함.

- use strict모드에서의 this?

  > 일반함수에서의 this는 undefined가 바인딩 됨

- [제로초 참고](https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb)

  다시 한 번, 정리하자면, this는 기본적으로 window이지만, 객체 메서드, bind call apply, new일 때 this가 바뀝니다. 그리고 이벤트리스너나 기타 라이브러리처럼 this를 내부적으로 바꿀 수도 있으니 항상 this를 확인해보셔야 하고요. 여러분이 선언한 function의 this는 항상 window라는 것 알아두세요.

<br/>

## <span id="es6">ES6</span>

- **크롬 정도의 브라우저를 제외하곤 ES6 스펙에 대한 지원이 완벽하지 않다. 해결방법은 무엇인가**

  > Babel을 사용한다. ES6이상의 문법의 코드들을 브라우저가 이해할 수 있게끔 ES5이하의 문법으로 변환

- **babel은 컴파일러 인가 ? 트랜스파일러인가?**

  > 트랜스파일러이다. 컴파일은 한 언어로 작성된 소스 코드를 다른 언어로 바꾸는것(C-> 어셈블리어) <br/>
  > 트랜스파일러는 한언어로 작성된 소스코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환 (C++>C, ES6->ES5)

- E**S6 에서 추가된 스펙에 대해 아는대로 다 말해달라**

  > let, const, 화살표함수, 클래스, 프로미스, 스프레드(전개) 연산자

- var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서)

  > var은 함수 레벨 스코프를 지원, let,const는 블록레벨 스코프를 지원한다.
  > <br/> 하여, 다음과 같이 블록레벨에 foo를 456으로 재선언하는 경우 foo를 456으로 인식
  > <br/> 하지만, let이나 const는 전역 변수를 읽는다 블록 안에 있는것을 읽지 않고

  ```javascript
  var foo = 123; // 전역 변수

  console.log(foo); // 123

  {
    var foo = 456; // 전역 변수
  }

  console.log(foo); // 456
  ```

- Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가

  > 구현가능하다. 자바스크립트에는 프로토타입이라는 것이 존재하여 클래스처럼 구현할 수 있다. <br/>
  > 클래스는 자바스크립트의 프로토타입 기반 패턴의 `문법적 설탕`이다.

<br/>

## <span id="call">Call by value & call by ref</span>

call by value 는 인자로 값이 넘어올때 복사된 값이 넘어오기 떄문에 중간에 어떤 연산을 해도 변하지 않는다.

```jsx
var a = 1;
var fun = funcion(b) {
	b=b+1;
}
fun(a)
console.log(a) // 1
```

자바스크립트는 기본적으로 원시값을 넘겨주면 call by value 로 작동 함수 내에서 값을 변경하면 함수에 전달된 데이터만 변경될 뿐 함수 전달된 원본 복사본에는 아무런 영향을 미치지 않는다.

call by reference는 인자로 레퍼런스가 넘어올때 가리키는 값을 복사하는 것이 아니라 참조 값을 넘기는 것

참조형 데이터는 그 값의 주소를 말 그대로 참조 할 값의 복사본이나 값 자체가 할당되지 않는다. 참조에 의해 할당된 새 변수는 원본 변수가 가르키는 값과 동일한 값을 가르킨다. 원본 변수와 할당된 변수는 모두 동등하며, 값을 조작하는데 사용될 수 있다. 그래서 할당된 변수(참조)가 변경되면 원본 변수에서도 동일하게 변경된다.

```jsx
var a = {};
var fun = funcion(b) {
	b.a=1;
}
fun(a)
console.log(a.a) // 1
```

<br/>

## <span id="null">NULL vs undefined</span>

> 기본적으로 둘다 값이 없음을 나타낸다.

undefiend는 데이터 타입이자 값을 나타냄. 정의되지 않은 것

null은 명시적으로 값이 비어있음을 나타내는데 사용

undefined는 변수를 선언만 한더라도 할당되지만, null은 변수를 선언한 후에 null로 값을 바꾼다.
